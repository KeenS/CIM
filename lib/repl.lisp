(defmacro handling-errors (&body body)
  `(handler-case (progn ,@body)
     (simple-condition (err) 
       (format *error-output* "~&~c[31m~A: ~c[39m~%" #\Esc (class-name (class-of err)) #\Esc)
       (apply (function format) *error-output*
              (simple-condition-format-control   err)
              (simple-condition-format-arguments err))
       (format *error-output* "~&")
       (force-output *error-output*))
     (condition (err) 
       (format *error-output* "~&~c[31m~A: ~%  ~A~c[39m~%"
               #\Esc (class-name (class-of err)) err #\Esc))))

(defun repl ()
  (do ((+eof+ (gensym))
       (hist 1 (1+ hist)))
      (nil)
    (format *query-io* "~%~c[36m~A[~c[35m~D~c[36m]>~c[39m " #\Esc (package-name *package*) #\Esc hist #\Esc #\Esc)
    (force-output *query-io*)
    (handling-errors
     (setf +++ ++   ++ +   + -   - (read *standard-input* nil +eof+))
     (when (or (eq - +eof+)
               (member - '((quit)(exit)(continue)) :test (function equal)))
       (return-from repl))
     (format *standard-output* "~c[33m" #\Esc)
     (setf /// //   // /   / (multiple-value-list (eval -)))
     (format *standard-output* "~c[39m" #\Esc)
     (setf *** **   ** *   * (first /))
     (force-output)
     (format *query-io* "~c[32m~& --> ~{~S~^ ;~%     ~}~%~c[39m"  #\Esc /  #\Esc)
     (force-output *query-io*))))
